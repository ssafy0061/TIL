# 4. 스택

- 스택
- 재귀호출
- Memoization
- DP
- DFS



## 스택(stack)의 특성

- 자료를 쌓아 올린 형태의 자료구조(저장하는 방법)
- 선형구조
  - 자료간의 관계가 1대1의 관계(앞, 뒤 등 한줄로)
  - 비선형구조: 자료간의 관계가 1대N의 관계(트리)
- 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있다.
- 마지막에 삽입한 자료를 가장 먼저 꺼낸다 = 후입선출(LIFO, Last-InFirst-Out)
  - 1, 2, 3 순으로 자료 삽입 후 꺼내면 역순으로 3, 2, 1 순으로 꺼낼 수 있다.



### 자료구조와 연산

- 스택을 프로그램에서 구현하기 위해 필요

- 자료구조: 자료를 선형으로 저장할 저장소

  - C언어에서는 배열을 사용
  - 저장소 자체를 스택이라 부르기도 함
  - 스택에서 마지막 삽입된 원소의 위치를 top이라 부름

- 연산

  - 삽입(**push**): 저장소에 자료 저장

    ```
    def push(item):
    	s.append(item)
    ```

  - 삭제(**pop**): 저장소에서 자료를 삽입의 역순으로 꺼냄

    ```python
    def pop():
    	if len(s) == 0:
            # underflow
            return
        else:
            return s.pop(-1)	# s.pop()으로 해도 됨
    ```

  - 스택이 공백인지 아닌지를 확인하는 연산: **isEmpty**

  - 스택의 top에 있는 item(원소)을 반환하는 연산: **peek**

### 스택 구현 고려사항

- 1차원 배열을 사용하여 구현할 경우
  - 장점: 구현 용이
  - 단점: 스택의 크기 변경 어려움
- 위 단점을 해결하는 방법: 스택의 동적 구현
  - 저장소를 **동적**으로 할당하여 스택 구현<br>즉, 동적 연결리스트를 이용하여 구현하는 방법
  - 장점: 메모리 효율적 사용
  - 단점: 구현이 복잡함



## 스택의 응용1: 괄호검사

- 종류: 대괄호([]), 중괄호({}), 소괄호(())
- 조건
  - 왼쪽 괄호의 개수 = 오른쪽 괄호의 개수
  - 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다.
  - 괄호 사이에는 포함 관계만 존재
- 잘못된 괄호 사용의 예
  - (a(b)
  - a(b)c)
  - a{b(c[d]e}f)

### 스택을 이용한 괄호검사

- (를 스택에 저장
- )가 오면 pop하여 비교
- 괄호 수식이 끝났는데 스택에 괄호가 남아있으면 오류

#### 알고리즘 개요

- 문자열에 있는 괄호를 차례대로 조사하면서
  - 왼쪽 괄호를 만나면 스택에 삽입
  - 오른쪽 괄호를 만나면 스택에서 top괄호를 삭제한 후<br>오른쪽 괄호와 짝이 맞는지 검사
- 이 때, 스택이 비어 있으면 조건1 또는 조건2에 위배되고<br>괄호의 짝이 맞지 않으면 조건3에 위배된다.
- 마지막 괄호까지를 조사한 후에도 스택에 괄호가 남아 있으면 조건1에 위배



## 스택의 응용2: Function call

- 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리

  - 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료, 복귀하는 후입선출 구조이므로<br>후입선출 구조의 스택을 이용하여 수행순서 관리
  - 함수 호출이 발생하면<br>호출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를<br>**스택 프레임(stack frame)에 저장하여 시스템 스택에 삽입**
  - 함수 실행이 끝나면<br>시스템 스택의 top 원소(스택 프레임)를 삭제(pop)하면서<br>프레임에 저장되어 있던 복귀주소를 확인하고 복귀
  - 함수 호출과 복귀에 따라 이 과정을 반복하여 전체 프로그램 수행이 종료되면<br>시스템 스택은 공백 스택이 된다.

  ```
  def main()
  	f_1()
  
  def f_1()
  	f_2()
  	
  def f_2()
  
  main()
  ```

  ① main() 실행

  - 

  - 

  - 

  - main() 함수 실행 관련 정보

  

  ② f_1() 호출

  ③ f_1() 실행

  - 

  - 

  - f_1() 함수 실행 관련 정보

  - main() 함수 실행 관련 정보

  

  ④ f_2() 호출

  ⑤ f_2() 실행 & 끝

  - 
  - f_2() 함수 실행 관련 정보    -> 실행끝나면 삭제(pop)

  - f_1() 함수 실행 관련 정보

  - main() 함수 실행 관련 정보

  

  ⑥ 복귀

  ⑦ f_1() 실행 끝

  - 

  - 

  - 

  - main() 함수 실행 관련 정보

  

  ⑧ 복귀

  ⑨ main() 실행 끝

  - 

  - 

  - 
  - 

## 스택 정리(리스트와 배열)

|       | s_list                                                       | s_arr                                                        |
| ----- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| push  | s_list.append(i)                                             | 스택이 가득 차 있는지 먼저 검사<br />top += 1<br />s_arr[top] = item |
| pop   | 공백인지 먼저 검사<br />아래 3가지 모두 같음<br />s_list.pop(-1)<br />s_list.pop()<br />s_list.pop(len(s_list)-1) | 공백인지 먼저 검사<br />N = s_arr[top]<br />top -= 1         |
| peek  | 공백검사<br />s_list[-1]                                     | 공백검사<br />s_arr[top]                                     |
| empty | if s_list:<br />또는<br />if len(s_list) == 0:               | if top == -1                                                 |
| Full  | 없음                                                         | if top == len(s_arr) - 1                                     |





# 재귀호출

- 자기 자신을 호출하여 순환 수행되는 것

- base case와 recursive case 2가지가 필요

  ```python
  # 팩토리얼 예시
  def fact(N: int) -> int:
      # base_case
      if N == 1:
          return 1
      # recursive_case
      ans = N * fact(N-1)
      
      return ans
  
  print(fact(4))
  # 결과
  24
  ```

  

### 재귀호출 예시

```python
def f(i, k):
    if i==k:	# 배열을 벗어나면(모든 원소에 대한 작업이 끝나면)
        return
    else:
        print(A[i])
        f(i+1, k)	# 다음 원소로 이동
        
        
N = 3
A = [10, 20 , 30]
f(0, N)		# 배열을 출력하는 함수

#결과
10
20
30
```

- 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다<br>재귀호출방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성

  - 예) factorial
  - n에 대한 factorial: 1부터 n까지의 모든 자연수를 곱하여 구하는 연산

  ```
  n! = n * (n-1)!
  (n-1)! = (n-1) * (n-2)!
  ...
  2! = 2 * 1!
  1! = 1
  ```

  - 마지막에 구한 하위 값을 이용하여 상위 값을 구하는 작업 반복



### 팩토리얼

- factorial 함수에서 n=4인 경우의 실행

  fact(4) 실행

  - 4 * fact(3)

  ① fact(3) 호출 

  - 3 * fact(2)

  ② fact(2) 호출

  - 2 * fact(1)

  ③ fact(1) 호출

  ④ 1 반환

  ⑤ 2 반환

  ⑥ 6 반환

  ⑦ 24 반환



### 피보나치

- 0과 1로 시작하고 이전의 두 수 합을 다음 항으로 하는 수열
  - 0, 1, 1, 2, 3, 5, 8, 13
- 피보나치 수열의 i번째 값을 계산하는 함수F를 정의하면 다음과 같다.
  - f(0) = 0, f(1) = 1
  - f(i) = f(i-1) + f(i-2) for i >= 2
- 위의 정의로부터 피보나치 수열의 i번째 항을 반환하는 함수를 재귀함수로 구현할 수 있다.

```python
def fivo(n):
	if n<2:
		return n
	return fibo(n-1) + fibo(n-2)
print(fivo(10))

# 결과
55
```





# Memoization

- 앞의 예에서 피보나치 수를 구하는 함수를 재귀하수로 구현한 알고리즘은<br>엄청난 중복 호출이 존재한다는 문제점 있음 Θ(2^n)
  - fib(2), fib(1)를 중복 호출 많이 함

- 메모이제이션(memoization)은 컴퓨터 프로그램을 실행할 때 이전에 게산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록하여 전체적인 실행속도를 빠르게 하는 기술
  - 동적 계획법의 핵심이 되는 기술
- memoization은 메모리에 넣기라는 뜻<br>memorization(기억하기)와는 다름
- 동사형은 memoize



- 앞의 예에서 피보나치 수를 구하는 알고리즘에서 fibo(n)의 값을 계산하자마자<br> 저장하면(memoize) 실행시간을 Θ(n)으로 줄일 수 있다.

### 알고리즘

- append 이용

```
memo를 위한 배열을 할당하고, 모두 0으로 초기화
memo[0]을 0으로 memo[1]는 1로 초기화
n = 50
def fibo1(n):
	if n >= 2 and len(memo) <= n:
		memo.append(fibo1(n-1) + fibo1(n-2))
	return memo[n]

memo = [0, 1]
print(fibo1(n))
```

- 수업 예시 (배열 이용)

```python
def fibo(n):
    if n>=2 and memo2[n]==0:
        memo2[n] = fibo(n-1) + fibo(n-2)
    return memo2[n]
n = 50
memo2 = [0] * (n+1)
memo2[0] = 0
memo2[1] = 1
print(fibo(n))
```





# DP(Dynamic Programming)

- 동적 계획(DP) 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘
- 동적 계획(DP) 알고리즘은 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후에<br>그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, <br> 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘

### 피보나치 수 DP 적용

- 피보나치 수는 부분 문제의 답으로부터 본 문제의 답을 얻을 수 있으므로 최적 부분 구조로 이루어져 있다.

#### DP 과정

- 문제를 부분 문제로 분할

  - fib(n)함수는 fib(n-1)과 fib(n-2)의 합
  - ...
  - fib(2)함수는 fib(1)과 fib(0)의 합
  - fib(n)은 fib(n-1), fib(n-2), ..., fib(2), fib(1), fib(0)의 부분집합으로 나뉜다

- 부분 문제로 나누는 일을 끝냈으면 가장 작은 부분 문제부터 해를 구한다.

- 그 결과는 테이블에 저장하고, 테이블에 저장된 부분 문제의 해를 이용하여 사우이 문제의 해를 구한다.

  | 테이블 인덱스 | 저장되어 있는 값 |
  | ------------- | ---------------- |
  | [0]           | 0                |
  | [1]           | 1                |
  | [2]           | 1                |
  | [3]           | 2                |
  | [4]           | 3                |
  | ...           | ...              |
  | [n]           | fibo(n)          |

#### 알고리즘

```
def fibo2(n):
	f = [0, 1]
	for i in range(2, n+1):
		f.append(f[i-1] + f[i-2])
		
	return f[n]
```

- 수업 예시

```python
def fibo(n):
	table[0] = 0
    table[1] = 1
    for i in tange(2, n+1):
        table[i] = table[i-1] + table[i-2]
    return table[n]

n = int(input())
table = [0]*(n+1)
print(fibo(n))
```



#### DP 구현 방식(정리)

- recursive 방식: fib1()
- iterative 방식: fib2()



- memoization을 재귀구조에 사용하는 것보다<br>반복적 구조로 DP를 구현한 것이 성능 면에서 보다 효율적이다.
- 재귀적 구조는 내부에 시스템 호출 스택을 사용하는 오버헤드가 발생하기 때문



- 수업 예시 (팩토리얼)

```python
def fact(n):
    table[0] = 1
    for i in range(1, n+1):
        table[i] = i * table[i-1]
    return table[n]

n = int(input())
table = [0] * (n+1)
print(fact(n))
```



# DFS(깊이우선탐색)

- 비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요
- 두 가지 방법
  - 깊이 우선 탐색(Depth First Search, DFS)
    - 스택 응용 방법의 하나
    - 재귀로도 가능
  - 너비 우선 탐색(Breadth First Search, BFS)
- 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지<br>깊이 탐색해 가다가더 이상 갈 곳이 없게 되면,<br>가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서<br>다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법
- 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서<br>다시 깊이 우선 탐색을 반복해야하므로 **후입선출 구조의 스택 사용**



### 알고리즘

(1) 시작 정점 v를 결정하여 방문

(2) 정점 v에 인접한 정점 중에서

- 방문하지 않은 정점 w가 있으면, 정점 v를 스택에 push하고 정점w를 방문<br>그리고 w를 v로 하여 다시 (2)를 반복

- 방문하지 않은 정점이 없으면 탐색의 방향을 바꾸기 위해서<br>스택을 pop하여 받은 가장 마지막 방문 정점을 v로 하여 다시 (2)를 반복

(3) 스택이 공백이 될 때까지 (2)를 반복

```
visited[], stack[] 초기화
DFS(v)
	v 방문;
	visited[v] <- true;
	do {
		if ( v의 인접 정점 중 방문 안한 w 찾기)
			push(v);
		while(w) {
			w 방문;
			visited[w] <-true;
			push(w);
			v<-w;
			v의 인접 정점 중 방문 안한 w 찾기
		}
		v <- pop(stack);
	} while(v)
end DFS()
```



### DFS 예

(1) 초기 상태: 배열 visited를 False로 초기화하고, 공백 스택을 생성

```
    A
  B   C
D   E
	F G
A-B, A-C
B-D, B-E, C-E
D-F, E-F
F-G

visited = [F, F, F, F, F, F, F]
stack = []
```



(2) 정점A를 시작으로 깊이 우선 탐색 시작

```
visited = [T, F, F, F, F, F, F]
```

정점 A에 방문하지 않은 정점 B, C가 있으므로<br>A를 스택에 push하고<br>인접 정점 B와 C중에서 오름차순에 따라 B를 선택하여 탐색을 계속한다.

```
visited = [T, T, F, F, F, F, F]
stack = [A]
```



(3) 정점 B에 방문하지 않은 정점 D, E가 있으므로<br>B를 스택에 push하고<br>인접 정점 D와 E중에서 오름차순에 따라 D를 선택하여 탐색을 계속한다.

```
visited = [T, T, F, T, F, F, F]
stack = [A, B]
```



(4) 정점 D에 방문하지 않은 정점 F가 있으므로<br>D를 스택에 push하고<br>인접 정점 F를 선택하여 탐색을 계속한다.

```
visited = [T, T, F, T, F, T, F]
stack = [A, B, D]
```



(5) 정점 G에 방문하지 않은 정점 E, F가 있으므로<br>G를 스택에 push하고<br>인접 정점 E와 F중에서 오름차순에 따라 E를 선택하여 탐색을 계속한다.

```
visited = [T, T, F, T, T, T, F]
stack = [A, B, D, F]
```



(6) 정점E에 방문하지 않은 정점 C가 있으므로<br>E를 스택에 push하고<br>인접 정점 C를 선택하여 탐색을 계속한다.

```
visited = [T, T, T, T, T, T, F]
stack = [A, B, D, F, E]
```



(7) 정점C에서 방문하지 않은 인접 정점이 없으므로<br>마지막 정점으로 돌아가기 위해 스택을 pop하여<br>받은 정점 E에 대해서 방문하지 않은 인접 정점이 있는지 확인한다.

```
visited = [T, T, T, T, T, T, F]
stack = [A, B, D, F]
```



(8) 정점E에서 방문하지 않은 인접 정점이 없으므로<br>다시 스택을 pop하여<br>받은 정점 F에 대해서 방문하지 않은 인접 정점이 있는지 확인한다.

```
visited = [T, T, T, T, T, T, F]
stack = [A, B, D]
```



(9) 정점 F에 방문하지 않은 정점 G가 있으므로<br>F를 스택에 push하고<br>인접정점 G를 선택하여 탐색을 계속한다.

```
visited = [T, T, T, T, T, T, T]
stack = [A, B, D, F]
```



(10) 정점 G에서 방문하지 않은 인접 정점이 없으므로<br>마지막 정점으로 돌아가기 위해 스택을 pop하여<br>받은 정점 F에 대해서 방문하지 않은 인접 정점이 있는지 확인한다.

```
visited = [T, T, T, T, T, T, T]
stack = [A, B, D]
```



(11) 정점 F에서 방문하지 않은 인접 정점이 없으므로<br>마지막 정점으로 돌아가기 위해 스택을 pop하여<br>받은 정점 D에 대해서 방문하지 않은 인접 정점이 있는지 확인한다.

```
visited = [T, T, T, T, T, T, T]
stack = [A, B]
```



(12) 정점 D에서 방문하지 않은 인접 정점이 없으므로<br>마지막 정점으로 돌아가기 위해 스택을 pop하여<br>받은 정점 D에 대해서 방문하지 않은 인접 정점이 있는지 확인한다.

```
visited = [T, T, T, T, T, T, T]
stack = [A]
```



(13) 정점 B에서 방문하지 않은 인접 정점이 없으므로<br>마지막 정점으로 돌아가기 위해 스택을 pop하여<br>받은 정점 A에 대해서 방문하지 않은 인접 정점이 있는지 확인한다.

```
visited = [T, T, T, T, T, T, T]
stack = []
```



(14) 현재 정점 A에서 방문하지 않은 인접 정점이 없으므로<br> 마지막 정점으로 돌아가기 위해 스택을 pop하는데<br> 스택이 공백이므로 깊이 우선 탐색을 종료한다.

- 깊이 우선 탐색 경로
  - A-B-D-F-E-C-G



### 연습문제

```
    1
  2   3
4   5
    6 7
    
1-2, 1-3
2-4, 2-5
4-6, 5-6
6-7, 3-7
```



다음은 연결되어 있는 두 개의 정점 사이의 간선을 순서대로 나열해 놓은 것이다.<br>모든 정점을 깊이 우선 탐색하여 경로를 출력하시오<br>(시작 정점은 1)

- 1, 2, 1, 3, 2, 4, 2, 5, 4, 6, 5, 6, 6, 7, 3, 7

- 출력 예
  - 1-2-4-6-5-7-3



### 알고리즘

````python
def dfs(s, V):
    visited = [0]*(V+1)
    stack = []
    i = s  # 현재 방문한 정점 i
    visited[i] = 1
    print(node[i])
    whlie i!=0:  #true:
        for w in range(1, V+1):
            if adj[i][w] == 1 and visited[w]==0:  # 인접 정점 중 오름차순으로 고름
                stack.append(i)  # 방문 경로 저장
                i = w			 # 새 방문지 이동
                visited[w] = 1
                print(node[i])   # 이동 후 방문한 곳 출력
                break
            else:
                if stack:
                    i = stack.pop()
                else:
                    i = 0
                    # break
                    
#          A  B  C  D  E  F  G
adj = [[0, 0, 0, 0, 0, 0, 0, 0], 
       [0, 0, 0, 0, 0, 0, 0, 0],   # A
       [0, 0, 0, 0, 0, 0, 0, 0],   # B
       [0, 0, 0, 0, 0, 0, 0, 0],   # C
       [0, 0, 0, 0, 0, 0, 0, 0],   # D
       [0, 0, 0, 0, 0, 0, 0, 0],   # E
       [0, 0, 0, 0, 0, 0, 0, 0],   # F
       [0, 0, 0, 0, 0, 0, 0, 0],]  # G
node = ['', 'A', 'B', 'C', 'D', 'E', 'F', 'G']


## 위 배열 만들기
# 정점의 개수, 마지막 정점 번호
# 간선
```
7 8
1 2
1 3
```
V, E = map(int, input().split())
ad = [[0]*(V+1) for _ in range(V+1)]
for _ in range(E):
    n1, n2 = map(int, input().split())
    ad[n1][n2] = 1
    ad[n2][n1] = 1
````

